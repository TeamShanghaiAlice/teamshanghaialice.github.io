---
layout: post
permalink: /python-number-to-chinese-chars
title: 用Python将阿拉伯数字转换为中文
---

# 用Python将阿拉伯数字转换为中文 #


一 中文数字的进制问题

这里先贴一段吧:

一般来说中文的数量单位有:  个十百千万十万百万千万亿, 亿以后就用的少了, 但是问题都是出在这个亿以后.

    中国报导社出版的《世界语课本》第十二课"一兆是多少"中，明确地说一兆是 milion-oble miliono=biliono（一百万个百万，即10的12次方）。要数完这一兆，假如按每分钟数200，每小时就是12000，每天288000，每年就是105120000（一亿零五百一十二万），数完一兆，需九千五百多年 这需多少代人接力数数 这个一兆就是一万个亿。它是中国13亿人口数的769倍多。但是，在我们平日工作中也常碰到"兆"。如无线电中就有表频率的"兆赫芝"，表电阻的"兆欧"，压力有"兆帕"，等等。然而现代科技所称的这个"兆"绝不是"万亿"，而是"百万"，亦即miliono,（即106。）它是万亿的的百万分之一，换言之，两个"兆"相差一百万倍 假如按上述办法数数，后一个兆则只要约三天半的时间即可数完!



    这究竟谁对呢？其实都是对的。这是怎麽回事？因为它们源自中国古代不同的计数体系。中国古代亿以上的大数计数方法有三个体系：这是我国东汉时期的《数述记遗》书中所载。



    一是上法，为自乘系统: 万万为亿，亿亿为兆，兆兆为京。这种系统，希腊的阿基米德也采用过；10^4=万, 10^8=亿,10^16=兆,10^32=京



    二是中法，为万进系统，皆以万递进：万 亿 兆 京 垓 秭 穰 沟(土旁) 涧 正 载┅┅(万万为亿 万亿为兆 万兆为京┅┅) ；10^4=万, 10^8=亿,10^12=兆,10^16=京



    三是下法，为十进系统，皆以十递进： 万 亿 、兆、京、垓、秭……到了近代，直至解放前我国还流行十进的系统，即个、十、百、千、万、亿、兆、京、垓、秭、穰、沟(土旁)、涧、正、载、报，皆以十进，10万为亿，10亿为兆，10兆为京......；10^4=万, 10^5=亿,10^6=兆,10^7=京



    现代的科学技术上用的"兆"属於第三法，就是 10^6，即百万。



    原来，我们平常生活中的兆，是有不同意思的。银行结算的多少多少兆货币单位，和电器上表示频率使用的多少多少兆赫芝，是不一样的数值。

    来自: http://zhidao.baidu.com/question/23464183.html



    http://wenda.tianya.cn/question/677fd30380d75933



    http://wenku.baidu.com/view/5fec1f67ddccda38376bafd3.html




上面罗里吧嗦一大推, 简言之就是:

    计算机里面的用法就是一兆=1024*1024,

    商家卖硬盘, 容量一兆也就是1M字节很多时候一兆=1000KB



    平常中国人的用法是 一兆 = 一万亿.


二 python将数字转换为中文

    比如 1234 转换为一千二百三十四

    123456 转换为 十二万三千四百五十六

    123056 转换为 十二万三千零五十六等等


小数字转换器来没什么难度, 难度就在于如果数字大于一亿了, 后面的事情, 就麻烦了, 你在转换的时候, 到底按照什么进制来转换? 你的最终结果就会根据进制的不同, 在中文数字计量单位上有所不同, 比如上面说的一兆, 中文常用的是一兆=一万亿, 但是在现代科技的很多领域, 一兆=一百万, 就是0.01个亿, 比亿还小.

不过为了完成这个任务, 还是假定一兆等于1万亿, 下面所有的代码的计算, 都是按照一万来切分单位的.

别的不多说了, 下面直接上代码, 我自己用着觉得还行, 有意见请留言.

    # -*- coding: utf-8 -*-

    hanzi_nums={

        '0':u'零',

        '1':u'一',

        '2':u'二',

        '3':u'三',

        '4':u'四',

        '5':u'五',

        '6':u'六',

        '7':u'七',

        '8':u'八',

        '9':u'九',

        '10':u'十',





    }

    hanzi_danwei=(

    (1,u''),

    (10,u'十'),

    (100,u'百'),

    (1000,u'千'),

    (10000,u'万'),

    (100000,u'十万'),

    (1000000,u'百万'),

    (10000000,u'千万'),

    (100000000,u'亿'),

    (1000000000,u'十亿'),

    (10000000000,u'百亿'),

    (100000000000,u'千亿'),

    (1000000000000,u'兆'),

    (10000000000000,u'十兆'),

    (100000000000000,u'百兆'),

    (1000000000000000,u'千兆'),

    (10000000000000000,u'京')

    )





    hanzi_danwei_dict={

        1:u'',

        10:u'十',

        100:u'百',

        1000:u'千',

        10000:u'万',

        100000:u'十万',

        1000000:u'百万',

        10000000:u'千万',

        100000000:u'亿',

        1000000000:u'十亿',

        10000000000:u'百亿',

        100000000000:u'千亿',

        1000000000000:u'兆',

        10000000000000:u'十兆',

        100000000000000:u'百兆',

        1000000000000000:u'千兆',

        10000000000000000:u'京'

    }





    def tans_num2hanzi(num):

        def tans_lt_99999(num_lt_99999):

            #print 'num:',num

            strNum =str(num_lt_99999)

            i = 0

            length=len(strNum)

            result=''

            for x in strNum:

                i +=1

                if x == '0':

                    result+='%s' % (hanzi_nums[x],)

                else:

                    result+='%s%s' % (hanzi_nums[x],hanzi_danwei[length-i][1])

            result = result.rstrip(u'零').replace(u'零零',u'零')

            return result





        lt_99999=num

        print lt_99999

        if len(str(lt_99999)) > 16:

            raise Exception('over the max num 10000000000000000')





        if lt_99999 < 10000:

            return tans_lt_99999(lt_99999)







        kkk=[]

        i=0

        while lt_99999/10000 != 0:

            deshu = lt_99999 / 10000

            chazhi = lt_99999-10000*deshu



            kkk.append((chazhi,i))

            lt_99999 = deshu

            i +=1

            #print lt_99999

        kkk.append((lt_99999,i))



        #print i,lt_99999,xxx,kkk,ccc

        result=[]

        for x in kkk[::-1]:

            result.append( '%s%s' %( tans_lt_99999(x[0]),  hanzi_danwei_dict[10000**x[1]]))

        return ''.join(result)


下面贴几个测试结果:

    7

    七

    607

    六百零七

    1607

    一千六百零七

    16070

    一万六千零七十

    99999

    九万九千九百九十九

    100000

    一十万

    160709

    一十六万七百零九

    16070930912345

    一十六兆七百零九亿三千零九十一万二千三百四十五


三 算法简介

主要是

1 将数字转换为字符串,

2 从左到右的处理字符串的所在地位, 不断的除以10000(以一万为进制), 得到的数值加入列表

3 反向处理上面的列表, 组合单位, 得到最终结果

四 未解决的问题

就是167090这个通常是转为十六万 七千零九十, 但是上面的那个是一十六万 七千零九十, 也就是说凡是 十几(计数单位) 都会被转成一十X, 一点小毛病.

五 互联网上的其他脚本

http://www.codesky.net/article/201112/122094.html

http://www.thinksaas.cn/group/topic/14299/

http://www.360doc.com/content/12/0814/03/21412_230051691.shtml

http://www.myexception.cn/perl-python/637899.html

http://bbs.chinaunix.net/thread-560817-1-1.html

http://www.oschina.net/code/snippet_70229_2389

http://www.oschina.net/code/snippet_16840_2001